
# Payment Gateway

## Deliverables

Build a simple Payment Gateway API that allows a merchant to:

- Process a payment through the payment gateway.
- Retrieve details of a previously made payment.

## Dependencies

The project depends on the following frameworks and packages.

- .NET 8
- NUnit3
- NUnit3TestAdapter
- FakeItEasy
- AutoFixture
- FluentValidation
- Microsoft.Extensions.Http.Resilience
- MediatR

## Build and Test

- Run `dotnet build` from within the `payment-gateway-challenge-dotnet` directory.

- Run `dotnet test` from within the `payment-gateway-challenge-dotnet` directory to run unit and integration tests.

_N.B._ _Some integration tests will fail after a delay if the Bank Simulator is not running._

## Local Run

- Run `dotnet run` from within the `payment-gateway-challenge-dotnet\src\PaymentGateway.Api` directory. This will launch the project on port 7092 (https). Navigate to <https://localhost:7092/swagger/index.html> to use the Swagger UI.
- Alternatively, run the API through Visual Studio setting the `PaymentGateway.Api` project as the start up project, which should bring up Swagger automatically.
- `docker-compose up` for the bank simulator provided.

## Examples

**POST /api/CreatePayment**

Use the 'Authorize' button in Swagger to input the following API key.

Api Key: `eOWSopHkGDm8DzFzlI998QZdFf6E9GNE43PVsfp38J5fCfX00374hXTqIscnKsc0` (in reality this will not be hard-coded but will be retrieved from a secure key vault / auth server!)

Valid Request

``` text
{
    "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "cardNumber": "1234567890123456",
    "expiryMonth": 12,
    "expiryYear": 2089,
    "currency": "GBP",
    "amount": 100,
    "cvv": "123"
}
```

200 OK Response

``` text
{
  "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "paymentStatusCode": 1,
  "cardNumberLastFour": "**** **** **** 3456",
  "expiryMonth": 12,
  "expiryYear": 2089,
  "currency": "GBP",
  "amount": 100,
  "reason": "OK",
  "paymentStatus": "Declined"
}
```

Invalid Request

``` text
{
    "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "cardNumber": "1234567A90123456",
    "expiryMonth": 12,
    "expiryYear": 2089,
    "currency": "GBP",
    "amount": 100,
    "cvv": "123"
}
```

400 Bad Request Response

``` text
{
  "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "errors": [
    "Card number must only contain numeric characters"
  ],
  "paymentStatusCode": 2,
  "paymentStatus": "Rejected"
}
```

## Architecture

The API follows the principles of Clean Architecture, where dependencies flow inwards towards the core Domain. The outermost layer is the API/Presentation layer, then the Application and Infrastructure layers, and finally the Domain layer. The interfaces for repositories and third party adapters are defined in the Domain layer and implemented in the Infrastructure layer. Additionally the CQRS pattern is used to allow for the Read and Write models to be uncoupled and scaled independently.

### API Layer

- Controllers
- Authentication middleware

### Application Layer

- Commands and Command Handlers
- Command Validators
- Queries and Query Handlers
- Response models

### Infrastructure Layer

- BankClient implementation (third party adapter)
- Repository implementation

### Domain Layer

- Core Entities
- BankClient Entities
- Interfaces

### Top-level Architecture Diagram

![Top-level Architecture][def]

## Key Decisions

- It is assumed that the unique `Id` for each payment is present in the incoming request and not generated by the Payment Gateway. This is done to handle duplicate requests which are identified by the unique id, and existing payments are returned without any duplicate processing.

- `FluentValidation` is used for strongly-typed validation on the incoming request. When the request fails validation, a 400 error response is returned with status 'Rejected' alongside error messages. No call is made to the Bank Simulator and no payment is persisted.

- When the Bank Simulator returns a non-200 response, the payment is treated as 'Declined' and the payment is persisted.

- When the Bank Simulator returns a 200 OK with unauthorized response, the payment is treated as 'Declined' and the payment is persisted.

- When the Bank Simulator returns a 200 OK with authorized response, the payment is treated as 'Authorized' and the payment is persisted.

- If there are any exceptional errors, a 500 Internal Server Error response is returned, and the exception is logged. This situation can be simulated by turning off the Bank Simulator - the response will take a few seconds due to the retry mechanism.

- The API validates against the currency codes of "GBP", "USD", and "EUR" only.

## Resilience

`Microsoft.Extensions.Http.Resilience` is used to implement a standard resilience handler (inclusive of default retry mechanism) so that the API is resilient to network failures when communicating with Bank Simulator.

## Security

API key based authentication has been implemented through middleware to protect the endpoints. The key is stored in `appsettings.json` and needs to be passed in the request header. In reality this key will come from a secure key-vault / authentication server!

## Error Handling and Logging

Default logging is used to log to the console. Exceptions are handled in specific components (like the `CommandHandler`) and logged. Incoming and outgoing requests are also logged.

## Testing

Unit tests exist for `CreatePaymentController`, `GetPaymentController`,`CreatePaymentCommandValidator`, `CreatePaymentCommandHandler` and `BankClient`.

Integration tests exist for `GetPaymentsController` and `CreatePaymentController`.

The Bank Simulator needs to be running for the integration tests to pass.

## Future Improvements

- **Mapping**: `AutoMapper` can be used to map domain objects to requests / responses and vice versa, imrpoving readability and removing the need for wordy and explicit mapping.
- **Data Storage**: In a real-life scenario, the `Repository` would be backed by an external data store, and a distributed cache like Redis could be used for fast lookup during payment reads.
- **Error handling**: Specialised logging libraries like Serilog could be used to ship logs to a cloudbased sink, for e.g., Azure Monitor / an ELK stash. Structured logging in conjunction with custom exceptions and global exception handling middleware can further improve error handling.
- **Security**: Simple API key based authentication has been used to protect the endpoints. This can be improved by using a more sophisticated approach such as merchant-specific JWT.
- **Resilience**: This could be enhanced by implementing client-specific rate-limits on the gateway endpoints alongside existing resilience measures implemented when calling the external Bank Simulator endpoint.
- **Async Background Processing**: Even though HTTP calls to the Bank Simulator are non-blocking and asynchronous, the experience from a clients' perspective is that of a synchronous API as a response is returned only after the Bank Simulator returns a response. This means that when retries to the external endpoint are triggered, it can take a few seconds for the API to return a response to the user.

    For a better user experience, as well as an improved ability to cope with spikes in requests, the API could return a response (e.g, "Payment initiated") immediately, while payment processing (write) is offloaded to an asynchronous background task via a message broker. Once the payment is processed, the client can be notified through webhooks / callbacks with the final payment response.

[def]: images/Architecture.png
